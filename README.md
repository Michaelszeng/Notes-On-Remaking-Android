# Notes-On-Remaking-Android

As explained in Notes-on-Robotics, I've spent (half of) the last few weeks developing `voxl-apps` (piece about what I've been doing in the other half coming soon :) ). The past few days have involved many discussions and redesigns and re-coding of the whole architecture, and, it's starting to look like my job is basically to recode (a much much simpler) Anroid OS for drone hardware (which is cool but how did I get here lol). Here, I want to explain what we've arrived at as of 7/19/2023.

Firstly, let me explain how Android's OS (IOS is quite similar) works. All Android apps are run in separate processes as the "system", in completely separate memory spaces (for safety and modularity). App processes, after they are forked, are actually never terminated. The processes are _paused_ when you switch out of them (when they are no longer dominating your screen), but they just sit in the background; and those app processes may also spawn other background services/processes that continue to monitor, say, GPS, even when the app isn't in the foreground. Even when you double click the home button and swipe app up to remove it from your "history", it still remains invisible, in the background. When you switch back to the app, the app's process is unpaused, continuing exactly where it left off when you paused it (Linux's SIGSTOP and SIGCONT are such that, literally, if you sent a SIGSTOP while the process was in the middle of a malloc, it would pauase the malloc, wait for a SIGCONT, then finish the malloc). The only time an app process is actually terminated is if it crashes, or if the devices is running low on resources and selects who to kill.

This model works great for mobile devices, but there are a few key differences when developing on a drone:
1. Pausing and resuming apps makes no sense for a drone. If you pause app1 while it's in the middle of following a trajectory, then switch to app2, which changes the position of the drone, resuming app1 afterwards no longer makes any sense (and is dangerous).
2. Android apps are state machines that just wait for user input to transition states; drones apps, on the other hand, will typically have a queue of actions (i.e. take off, fly to warehouse shelf, hover ...) that must run sequentially and uninterrupted.

Therefore, the Android model of "pausing" and "resuming" apps doesn't really work; `voxl-apps` needs to be different in many ways. This is a summary of how `voxl-apps` is being designed: 
- Similar to Android, apps will still be run in separate processes with separate memory space
- Similar to Android, apps will also never be terminated unless they crash; apps can run forever, waiting for potential new primitive to be pushed to queue.
- Similar to Android, apps will have user-defined `onInit`, `onStart`, `onStop`, etc. functions that get called when the app is loaded, "activated", "deactivated", etc. Apps will not have an `onClick` function like Android; instead, apps will have a `loop` function that the system repeatedly runs (at as high a frequency as possible), similar to Aruduino's `loop` function. In this loop function, the user can read from sensors and define behaviors, or even spawn off other threads. (Interrupt functions may be a future feature???) The reason for this difference is that the number of ways to interface with a drone (i.e. sensors, terminal commands, RC controller) is much more than the number of ways to interface with a tablet (which is like only clicking), so creating callbacks for every possible input would be a lot.
- Unliked Android, when an "active" app is switched away from, the process won't be paused; it will receive a message over pipe that turns an "inactive" flag high and interrupts its queue of primitives, but the process will still be alive.
- Similar to Android, "inactive" apps will still receive updates from "the system" (`voxl-app-manager`). This way, if an inactive app is "activated", it will have up to date information on the drone's position and whatever it was doing (in case this should impact the new app's behavior).
- Unliked Android, when an "inactive" app is "activated", it will begin at back at the start of its queue. It won't entirely restart/rerun its initialization procedure, but it will restart it's pre-programmed actions.

One downside to this architecture is that, if you wanted to literally spontaneously stop/pause the drone for an undefined amount of time, then resume whatever procedure it was doing, you can't easily do that (Android does this by simply pausing and resuming the app process). Therefore, we're also building in functions that specifically tell the drone to sit still for a period of time and to stop sitting still/resume whatever primitive it was running before.

Coming up with this was pretty mind-boggling; there's an infinite number of ways you could design the `voxl-apps` OS and it's impossible to think it all through without trying to implement it. And it's really fun how every week I spend several hours brainstorming, then code a ton of stuff, then review it with my team, and we realize there is a better way to do things, then I end up re-brainstorming and then re-coding most of it the next week. Even though it's kind of painful, it's definitely not boring. But I think I prefer robotics and coding how to make things move.

While we're talking about painful things, debugging multi-threaded multi-processed (is that a word?) applications is extruciating; I often spend multiple full days debugging one segfault. On the bright side, now when I debug errors and segfaults not related to multi-whatevering, it's a piece of cake.

It's also kind of crazy to me that I have only 3 weeks of C training (MIT's 6.190) and one project that involved C and Zephyr under my belt, and now I am tasked with building an OS. It certainly is overwhelming when everything segfaults and all the POSIX pipes explode, but having the whole `voxl` codebase at my fingertips (and chatgpt) has made the learning experience pretty smooth; it's not been as difficult as it sounds. 


Update 7/28/23: Fake Android is "done". Fair amount of torture testing and 1 rare/non-repeatable bug remaining that is pretty non-fatal. I started this project on Jun 22. 5 weeks and ~4,000 lines of code (that still exist in the codebase now) later, I not only have a robust OS working, I also went from a beginner level understanding of C, memory/pointers, and Linux to what I what I would call pretty experienced and confident in my skills. Much thanks to James for giving me a great project.

Next step is to integrate this with Mavlink and ModalAI's other services so that this OS and its apps can actually make a drone fly.
