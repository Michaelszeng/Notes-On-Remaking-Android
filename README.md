# Notes-On-Remaking-Android

As explained in Notes-on-Robotics, I've spent (half of) the last few weeks developing `voxl-apps`. The past few days have involved many discussions and redesigns and re-coding of the whole architecture, and, it's starting to look like my job is basically to recode (a much simpler) Anroid OS for drone hardware (which is cool but how did I get here lol). Here, I want to explain what we've arrived at as of 7/19/2023.

Firstly, let me explain how Android's OS (IOS is quite similar) works; I only regret not reading more about this when I first started working on `voxl-apps`. All Android apps are run in separate processes, in completely separate memory spaces (for safety and modularity). App processes, after they are forked, are actually never terminated. The processes are _paused_ when you switch out of them (when they are no longer dominating your screen), but those app processes may spawn other background services/processes that continue to monitor, say, GPS, even when the app isn't in the foreground. When you switch back to the app, the app's process is unpaused, continuing exactly where it left off (Linux's SIGSTOP and SIGCONT are such that, literally, if you sent a SIGSTOP while the process was in the middle of a malloc, it would pauase the malloc, wait for a SIGCONT, then finish the malloc). The only time an app process is actually terminated is if it crashes, or if the devices is running low on resources.

This model works great for mobile devices, but there are a few key differences when developing on a drone:
1. Pausing and resuming apps makes no sense for a drone. If you pause app1 while it's in the middle of following a trajectory, then switch to app2, which changes the position of the drone, resuming app1 afterwards no longer makes any sense (and is dangerous).
2. Android apps are just state machines that just wait for user input to transition states; drones apps, on the other hand, will typically have a queue of actions (i.e. take off, fly to warehouse shelf, hover ...) that must run sequentially and uninterrupted.

Therefore, `voxl-apps` needs to be different in many ways. This is a summary of how `voxl-apps` shall be designed: 
- Apps will still be run in separate processes with separate memory space
- Apps will also never be terminated unless they crash; apps can run forever, waiting for potential new primitive to be pushed to queue.
- Apps will have user-defined `onInit`, `onStart`, `onStop`, etc. functions, similar to Android, that get called when the app is loaded, "activated", "deactivated", etc. Apps will not have an `onClick` function like Android; instead, apps will have a `loop` function that the system repeatedly runs (at as high a frequency as possible), similar to Aruduino's `loop` function. In this loop function, the user can read from sensors and define behaviors, or even spawn off other threads. (Interrupt functions may be a future feature???) The reason for this difference is that the number of ways to interface with a drone (i.e. sensors, terminal commands, RC controller) is much more than the number of ways to interface with a tablet (which is like only clicking), so creating callbacks for every possible input would be a lot.
- When an "active" app is switched away from, the process won't be paused; it will receive a message over pipe that turns an "inactive" flag high and interrupts its queue of primitives, but the process will still be alive.
- "Inactive" apps will still receive updates from "the system" (`voxl-app-manager`). This way, if an inactive app is "activated", it will have up to date information on the drone's position and whatever it was doing (in case this should impact the new app's behavior).
- When an "inactive" app is "activated", it will begin at back at the start of its queue.
- During an app's execution, the app will continuously check the "inactive" flag, and if it finds that it is true, it will stop execution.

One downside to this architecture is that, if you wanted to literally spontaneously stop/pause the drone for an undefined amount of time, then resume whatever procedure it was doing, you can't easily do that (Android does this by simply pausing and resuming the app process). Therefore, we're also building in primitives and functions that specifically tell the drone to sit still for a period of time and to stop sitting still and resume whatever primitive it was running before.

All this is pretty mind-boggling; it's really fun how every week I spend several hours brainstorming, then code a ton of stuff, then review it with my team, and then I end up re-brainstorming and then re-coding most of it the next week. OS design is pretty complicated, no matter how thoroughly I try to think things through. It's definitely not boring though, but I think I prefer robotics and coding how to make things move.

It's also kind of crazy to me that I have only 3 weeks of C training (MIT's 6.190) and one project that involved C and Zephyr under my belt, and now I am tasked with building an OS. It deifnitely is overwhelming when everything segfaults and all the POSIX pipes explode, but having the whole `voxl` codebase at my fingertips (and chatgpt) has made the learning experience pretty smooth; it's not been as hard as it sounds. 
